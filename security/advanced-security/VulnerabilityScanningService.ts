import { VulnerabilityResult, SecurityConfiguration } from '../types';
import { EventEmitter } from 'events';
import axios from 'axios';

interface ScanTarget {
  id: string;
  name: string;
  type: 'dependency' | 'container' | 'infrastructure' | 'application' | 'database';
  location: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  schedule: string;
  last_scanned: Date | null;
  enabled: boolean;
}

interface VulnerabilityDatabase {
  source: 'nvd' | 'snyk' | 'github' | 'custom';
  last_updated: Date;
  vulnerability_count: number;
  url: string;
}

export class VulnerabilityScanningService extends EventEmitter {
  private vulnerabilities: VulnerabilityResult[] = [];
  private scanTargets: ScanTarget[] = [];
  private vulnerabilityDatabases: VulnerabilityDatabase[] = [];
  private activeScanners: Map<string, boolean> = new Map();
  private scanHistory: Array<{ id: string; timestamp: Date; results: VulnerabilityResult[] }> = [];
  private isInitialized = false;

  constructor() {
    super();
    this.initializeScanTargets();
    this.initializeVulnerabilityDatabases();
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    
    await this.updateVulnerabilityDatabases();
    await this.schedulePeriodicScans();
    this.isInitialized = true;
  }

  async performComprehensiveScan(): Promise<VulnerabilityResult[]> {
    const scanId = `scan_${Date.now()}`;
    const allResults: VulnerabilityResult[] = [];

    try {
      this.emit('scan_started', { scanId, timestamp: new Date() });

      const scanPromises = this.scanTargets
        .filter(target => target.enabled)
        .map(target => this.scanTarget(target));

      const scanResults = await Promise.allSettled(scanPromises);
      
      scanResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          allResults.push(...result.value);
        } else {
          this.emit('scan_error', { 
            target: this.scanTargets[index].id, 
            error: result.reason 
          });
        }
      });

      this.vulnerabilities.push(...allResults);
      this.scanHistory.push({
        id: scanId,
        timestamp: new Date(),
        results: allResults
      });

      this.emit('scan_completed', { 
        scanId, 
        vulnerabilities: allResults.length,
        critical: allResults.filter(v => v.severity === 'critical').length,
        high: allResults.filter(v => v.severity === 'high').length
      });

      return allResults;
    } catch (error) {
      this.emit('scan_failed', { scanId, error });
      throw error;
    }
  }

  private async scanTarget(target: ScanTarget): Promise<VulnerabilityResult[]> {
    this.activeScanners.set(target.id, true);
    const results: VulnerabilityResult[] = [];

    try {
      switch (target.type) {
        case 'dependency':
          results.push(...await this.scanDependencies(target));
          break;
        case 'container':
          results.push(...await this.scanContainer(target));
          break;
        case 'infrastructure':
          results.push(...await this.scanInfrastructure(target));
          break;
        case 'application':
          results.push(...await this.scanApplication(target));
          break;
        case 'database':
          results.push(...await this.scanDatabase(target));
          break;
      }

      target.last_scanned = new Date();
      return results;
    } finally {
      this.activeScanners.set(target.id, false);
    }
  }

  private async scanDependencies(target: ScanTarget): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Simulate dependency scanning (would integrate with tools like npm audit, Snyk, etc.)
      const packageJson = await this.readPackageJson(target.location);
      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

      for (const [packageName, version] of Object.entries(dependencies)) {
        const packageVulns = await this.checkPackageVulnerabilities(packageName, version as string);
        vulnerabilities.push(...packageVulns);
      }

      // Add some common vulnerability patterns
      if (dependencies['express'] && this.isVersionVulnerable(dependencies['express'] as string, '4.17.0')) {
        vulnerabilities.push({
          id: `vuln_${Date.now()}_express`,
          cve_id: 'CVE-2022-24999',
          severity: 'medium',
          title: 'Express.js Prototype Pollution',
          description: 'Express.js vulnerable to prototype pollution via qs dependency',
          affected_component: 'express',
          version: dependencies['express'] as string,
          fix_version: '4.18.0',
          exploit_available: false,
          cvss_score: 5.3,
          first_discovered: new Date(),
          last_seen: new Date(),
          patched: false,
          patch_available: true,
          remediation_effort: 'low'
        });
      }

      if (dependencies['jsonwebtoken'] && this.isVersionVulnerable(dependencies['jsonwebtoken'] as string, '8.5.1')) {
        vulnerabilities.push({
          id: `vuln_${Date.now()}_jwt`,
          cve_id: 'CVE-2022-23529',
          severity: 'high',
          title: 'JsonWebToken Signature Bypass',
          description: 'JWT signature verification bypass vulnerability',
          affected_component: 'jsonwebtoken',
          version: dependencies['jsonwebtoken'] as string,
          fix_version: '9.0.0',
          exploit_available: true,
          cvss_score: 7.6,
          first_discovered: new Date(),
          last_seen: new Date(),
          patched: false,
          patch_available: true,
          remediation_effort: 'medium'
        });
      }

    } catch (error) {
      this.emit('dependency_scan_error', { target: target.id, error });
    }

    return vulnerabilities;
  }

  private async scanContainer(target: ScanTarget): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Simulate container scanning (would integrate with tools like Trivy, Clair, etc.)
      const containerInfo = await this.getContainerInfo(target.location);
      
      // Check base image vulnerabilities
      const baseImageVulns = await this.scanBaseImage(containerInfo.baseImage);
      vulnerabilities.push(...baseImageVulns);

      // Check for common container misconfigurations
      const configVulns = await this.scanContainerConfiguration(target.location);
      vulnerabilities.push(...configVulns);

    } catch (error) {
      this.emit('container_scan_error', { target: target.id, error });
    }

    return vulnerabilities;
  }

  private async scanInfrastructure(target: ScanTarget): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Network infrastructure scanning
      const networkVulns = await this.scanNetworkInfrastructure(target.location);
      vulnerabilities.push(...networkVulns);

      // Cloud configuration scanning
      const cloudVulns = await this.scanCloudConfiguration(target.location);
      vulnerabilities.push(...cloudVulns);

    } catch (error) {
      this.emit('infrastructure_scan_error', { target: target.id, error });
    }

    return vulnerabilities;
  }

  private async scanApplication(target: ScanTarget): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Static application security testing (SAST)
      const sastResults = await this.performSAST(target.location);
      vulnerabilities.push(...sastResults);

      // Dynamic application security testing (DAST)
      const dastResults = await this.performDAST(target.location);
      vulnerabilities.push(...dastResults);

    } catch (error) {
      this.emit('application_scan_error', { target: target.id, error });
    }

    return vulnerabilities;
  }

  private async scanDatabase(target: ScanTarget): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Database configuration scanning
      const dbConfigVulns = await this.scanDatabaseConfiguration(target.location);
      vulnerabilities.push(...dbConfigVulns);

      // Database access control scanning
      const accessVulns = await this.scanDatabaseAccess(target.location);
      vulnerabilities.push(...accessVulns);

    } catch (error) {
      this.emit('database_scan_error', { target: target.id, error });
    }

    return vulnerabilities;
  }

  // Mock implementations for demonstration
  private async readPackageJson(location: string): Promise<any> {
    return {
      dependencies: {
        'express': '^4.16.0',
        'jsonwebtoken': '^8.5.0',
        'mongoose': '^6.0.0',
        'bcryptjs': '^2.4.0'
      },
      devDependencies: {
        'vitest': '^3.0.0',
        'typescript': '^5.0.0'
      }
    };
  }

  private async checkPackageVulnerabilities(packageName: string, version: string): Promise<VulnerabilityResult[]> {
    // Mock vulnerability check - would integrate with actual vulnerability databases
    return [];
  }

  private isVersionVulnerable(currentVersion: string, vulnerableVersion: string): boolean {
    // Simple version comparison - would use proper semver comparison
    return currentVersion.includes(vulnerableVersion.split('.')[0]);
  }

  private async getContainerInfo(location: string): Promise<{ baseImage: string }> {
    return { baseImage: 'node:18-alpine' };
  }

  private async scanBaseImage(baseImage: string): Promise<VulnerabilityResult[]> {
    // Mock base image vulnerability scan
    if (baseImage.includes('alpine')) {
      return [{
        id: `vuln_${Date.now()}_alpine`,
        severity: 'low',
        title: 'Alpine Linux Package Vulnerability',
        description: 'Outdated package in Alpine Linux base image',
        affected_component: 'alpine-base',
        version: '3.16',
        cvss_score: 3.1,
        first_discovered: new Date(),
        last_seen: new Date(),
        exploit_available: false,
        patched: false,
        patch_available: true,
        remediation_effort: 'low'
      }];
    }
    return [];
  }

  private async scanContainerConfiguration(location: string): Promise<VulnerabilityResult[]> {
    return [{
      id: `vuln_${Date.now()}_container_config`,
      severity: 'medium',
      title: 'Container Running as Root',
      description: 'Container is configured to run as root user',
      affected_component: 'container-runtime',
      version: 'latest',
      cvss_score: 4.8,
      first_discovered: new Date(),
      last_seen: new Date(),
      exploit_available: false,
      patched: false,
      patch_available: true,
      remediation_effort: 'low'
    }];
  }

  private async scanNetworkInfrastructure(location: string): Promise<VulnerabilityResult[]> {
    return [];
  }

  private async scanCloudConfiguration(location: string): Promise<VulnerabilityResult[]> {
    return [];
  }

  private async performSAST(location: string): Promise<VulnerabilityResult[]> {
    return [{
      id: `vuln_${Date.now()}_sast`,
      severity: 'medium',
      title: 'Potential SQL Injection',
      description: 'Dynamic SQL query construction detected',
      affected_component: 'claims-service',
      version: '1.0.0',
      cvss_score: 5.9,
      first_discovered: new Date(),
      last_seen: new Date(),
      exploit_available: false,
      patched: false,
      patch_available: false,
      remediation_effort: 'medium'
    }];
  }

  private async performDAST(location: string): Promise<VulnerabilityResult[]> {
    return [];
  }

  private async scanDatabaseConfiguration(location: string): Promise<VulnerabilityResult[]> {
    return [{
      id: `vuln_${Date.now()}_db_config`,
      severity: 'high',
      title: 'Weak Database Authentication',
      description: 'Database using default or weak authentication settings',
      affected_component: 'mongodb',
      version: '6.0',
      cvss_score: 7.5,
      first_discovered: new Date(),
      last_seen: new Date(),
      exploit_available: false,
      patched: false,
      patch_available: true,
      remediation_effort: 'low'
    }];
  }

  private async scanDatabaseAccess(location: string): Promise<VulnerabilityResult[]> {
    return [];
  }

  async getRecentVulnerabilities(limit: number = 10): Promise<VulnerabilityResult[]> {
    return this.vulnerabilities
      .sort((a, b) => b.first_discovered.getTime() - a.first_discovered.getTime())
      .slice(0, limit);
  }

  async getVulnerabilitiesBySeverity(severity: string): Promise<VulnerabilityResult[]> {
    return this.vulnerabilities.filter(vuln => vuln.severity === severity);
  }

  async getVulnerabilityById(id: string): Promise<VulnerabilityResult | null> {
    return this.vulnerabilities.find(vuln => vuln.id === id) || null;
  }

  async markVulnerabilityAsPatched(id: string): Promise<boolean> {
    const vulnerability = this.vulnerabilities.find(vuln => vuln.id === id);
    if (vulnerability) {
      vulnerability.patched = true;
      this.emit('vulnerability_patched', vulnerability);
      return true;
    }
    return false;
  }

  async getVulnerabilityStatistics(): Promise<{
    total: number;
    by_severity: Record<string, number>;
    by_component: Record<string, number>;
    patched_percentage: number;
    average_cvss: number;
  }> {
    const total = this.vulnerabilities.length;
    const bySeverity: Record<string, number> = {};
    const byComponent: Record<string, number> = {};
    let totalCvss = 0;
    let patchedCount = 0;

    this.vulnerabilities.forEach(vuln => {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1;
      byComponent[vuln.affected_component] = (byComponent[vuln.affected_component] || 0) + 1;
      totalCvss += vuln.cvss_score;
      if (vuln.patched) patchedCount++;
    });

    return {
      total,
      by_severity: bySeverity,
      by_component: byComponent,
      patched_percentage: total > 0 ? (patchedCount / total) * 100 : 0,
      average_cvss: total > 0 ? totalCvss / total : 0
    };
  }

  async addScanTarget(target: Omit<ScanTarget, 'id' | 'last_scanned'>): Promise<string> {
    const newTarget: ScanTarget = {
      ...target,
      id: `target_${Date.now()}`,
      last_scanned: null
    };
    
    this.scanTargets.push(newTarget);
    this.emit('scan_target_added', newTarget);
    
    return newTarget.id;
  }

  async removeScanTarget(targetId: string): Promise<boolean> {
    const index = this.scanTargets.findIndex(t => t.id === targetId);
    if (index === -1) return false;
    
    this.scanTargets.splice(index, 1);
    this.emit('scan_target_removed', targetId);
    
    return true;
  }

  async isHealthy(): Promise<boolean> {
    return this.isInitialized && 
           this.vulnerabilityDatabases.length > 0 &&
           Array.from(this.activeScanners.values()).filter(Boolean).length < 5; // Max 5 concurrent scans
  }

  private initializeScanTargets(): void {
    this.scanTargets = [
      {
        id: 'dependencies_main',
        name: 'Main Application Dependencies',
        type: 'dependency',
        location: './package.json',
        priority: 'high',
        schedule: '0 6 * * *', // Daily at 6 AM
        last_scanned: null,
        enabled: true
      },
      {
        id: 'container_web',
        name: 'Web Application Container',
        type: 'container',
        location: './Dockerfile',
        priority: 'medium',
        schedule: '0 2 * * 1', // Weekly on Monday at 2 AM
        last_scanned: null,
        enabled: true
      },
      {
        id: 'application_code',
        name: 'Application Source Code',
        type: 'application',
        location: './client',
        priority: 'high',
        schedule: '0 4 * * *', // Daily at 4 AM
        last_scanned: null,
        enabled: true
      },
      {
        id: 'database_mongodb',
        name: 'MongoDB Database',
        type: 'database',
        location: 'mongodb://localhost:27017',
        priority: 'critical',
        schedule: '0 3 * * *', // Daily at 3 AM
        last_scanned: null,
        enabled: true
      }
    ];
  }

  private initializeVulnerabilityDatabases(): void {
    this.vulnerabilityDatabases = [
      {
        source: 'nvd',
        last_updated: new Date(),
        vulnerability_count: 250000,
        url: 'https://nvd.nist.gov/feeds/json/cve/1.1/'
      },
      {
        source: 'github',
        last_updated: new Date(),
        vulnerability_count: 45000,
        url: 'https://api.github.com/advisories'
      },
      {
        source: 'snyk',
        last_updated: new Date(),
        vulnerability_count: 180000,
        url: 'https://snyk.io/vuln'
      }
    ];
  }

  private async updateVulnerabilityDatabases(): Promise<void> {
    for (const db of this.vulnerabilityDatabases) {
      try {
        // Mock database update - would fetch real vulnerability data
        db.last_updated = new Date();
        this.emit('vulnerability_db_updated', db);
      } catch (error) {
        this.emit('vulnerability_db_error', { source: db.source, error });
      }
    }
  }

  private async schedulePeriodicScans(): Promise<void> {
    // Implementation would use node-cron for scheduling
    setInterval(async () => {
      try {
        await this.performComprehensiveScan();
      } catch (error) {
        this.emit('scheduled_scan_error', error);
      }
    }, 24 * 60 * 60 * 1000); // Daily scans
  }
}
